{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"learning-log","text":"<ul> <li>Short notes I don\u2019t want to forget.</li> <li>Use search for keywords.</li> <li>Use tags for cross-topic browsing.</li> </ul>"},{"location":"blog/","title":"Posts","text":""},{"location":"blog/tags/","title":"Tags","text":""},{"location":"blog/tags/#tag:aws","title":"AWS","text":"<ul> <li>            Cross Account ECR Image Pull in EKS Cluster          </li> </ul>"},{"location":"blog/tags/#tag:docker","title":"Docker","text":"<ul> <li>            Cross Account ECR Image Pull in EKS Cluster          </li> </ul>"},{"location":"blog/tags/#tag:eks","title":"EKS","text":"<ul> <li>            Cross Account ECR Image Pull in EKS Cluster          </li> </ul>"},{"location":"blog/tags/#tag:terraform","title":"Terraform","text":"<ul> <li>            Terraform subnet splitting          </li> </ul>"},{"location":"blog/tags/#tag:cidrsubnet","title":"cidrsubnet","text":"<ul> <li>            Terraform subnet splitting          </li> </ul>"},{"location":"blog/tags/#tag:config","title":"config","text":"<ul> <li>            Per directory git user details for different projects          </li> </ul>"},{"location":"blog/tags/#tag:git","title":"git","text":"<ul> <li>            Per directory git user details for different projects          </li> </ul>"},{"location":"blog/tags/#tag:identity","title":"identity","text":"<ul> <li>            Per directory git user details for different projects          </li> </ul>"},{"location":"blog/2025/12/15/per-directory-git-indentity/","title":"Per-directory git user details with includeIf","text":"<p>If you keep repos grouped by folder, for example: - All work related git repositories in folder <code>~/code/work</code> - All personal git repositories in folder <code>~/code/personal</code></p> <p>then you can set different user details, like <code>user.name</code> or <code>user.email</code>, automatically using conditional includes.</p>","tags":["git","config","identity"]},{"location":"blog/2025/12/15/per-directory-git-indentity/#example","title":"Example","text":"<p>Create <code>~/.gitconfig</code> file and ensure <code>includeIf</code> for each repository group:</p> <pre><code>[user]\n  name = &lt;Your Name&gt;\n  email = your-primary-email@domain.com\n\n## other options\n\n[includeIf \"gitdir:~/code/work/\"]\n  path = ~/.gitconfig-work\n\n[includeIf \"gitdir:~/code/personal/\"]\n  path = ~/.gitconfig-personal\n\n## rest of the options\n</code></pre> <p>and then create <code>~/.gitconfig-work</code> and <code>~/.gitconfig-personal</code> files with their own contents.</p> <p><code>~/.gitconfig-work</code>:</p> <pre><code>[user]\n  email = work-email@company.com\n</code></pre> <p><code>~/.gitconfig-personal</code>:</p> <pre><code>[user]\n  email = personal-email@example.com\n</code></pre>","tags":["git","config","identity"]},{"location":"blog/2026/01/18/terraform-subnet-splitting/","title":"Subnet Splitting in Terraform using <code>cidrsubnet</code>","text":"<p>When creating VPCs in AWS, one of the most common tasks is splitting your VPC CIDR block into multiple subnets across different availability zones. This is something I do frequently but always forget the exact approach, so I'm documenting it here for future reference.</p>","tags":["Terraform","cidrsubnet"]},{"location":"blog/2026/01/18/terraform-subnet-splitting/#understanding-cidrsubnet","title":"Understanding <code>cidrsubnet</code>","text":"<p>Terraform's <code>cidrsubnet</code> function is the key to this approach. It has the following signature:</p> <pre><code>cidrsubnet(prefix, newbits, netnum)\n</code></pre> <ul> <li>prefix: The base CIDR block (e.g., <code>10.0.0.0/16</code>)</li> <li>newbits: Number of additional bits to add to the prefix length</li> <li>netnum: The subnet number (0-indexed) to create</li> </ul> <p>The function creates <code>2^newbits</code> possible subnets, and <code>netnum</code> selects which one.</p>","tags":["Terraform","cidrsubnet"]},{"location":"blog/2026/01/18/terraform-subnet-splitting/#two-level-splitting-approach","title":"Two-Level Splitting Approach","text":"<p>My approach uses a two-level hierarchy:</p> <ol> <li>First level: Split the VPC CIDR into three subnet types (web, backend, datastore)</li> <li>Second level: Split each block per availability zone</li> </ol>","tags":["Terraform","cidrsubnet"]},{"location":"blog/2026/01/18/terraform-subnet-splitting/#first-level-web-backend-and-datastore","title":"First Level: Web, Backend, and Datastore","text":"<p>The three subnet types serve different purposes: - Web subnets: Publicly available services (with Internet Gateway) - Backend subnets: Other services that need outbound internet access (with NAT Gateway) - Datastore subnets: Data services that don't need internet access (no NAT Gateway)</p> <pre><code>vpc_web_subnet_block = cidrsubnet(var.vpc_cidr, 2, 0)\nvpc_backend_subnet_block = cidrsubnet(var.vpc_cidr, 2, 1)\nvpc_datastore_subnet_block = cidrsubnet(var.vpc_cidr, 2, 2)\n</code></pre> <p>Using <code>newbits = 2</code> creates 4 possible subnets (2^2 = 4), and we use 3 of them: - <code>netnum = 0</code> \u2192 Web subnets (publicly accessible) - <code>netnum = 1</code> \u2192 Backend subnets (with NAT Gateway) - <code>netnum = 2</code> \u2192 Datastore subnets (no NAT Gateway) - <code>netnum = 3</code> \u2192 Unused (available for future expansion)</p> <p>Example: If <code>vpc_cidr = \"10.0.0.0/16\"</code>: - Web block: <code>10.0.0.0/18</code> (first quarter) - Backend block: <code>10.0.64.0/18</code> (second quarter) - Datastore block: <code>10.0.128.0/18</code> (third quarter)</p>","tags":["Terraform","cidrsubnet"]},{"location":"blog/2026/01/18/terraform-subnet-splitting/#second-level-per-availability-zone","title":"Second Level: Per Availability Zone","text":"<p>The number of bits needed depends on how many availability zones you're using:</p> <pre><code>number_of_zones = var.env_type == \"production\" ? 3 : 2\nzone_bits = local.number_of_zones == 2 ? 1 : 2\n</code></pre> <ul> <li>2 AZs: Use <code>zone_bits = 1</code> (creates 2^1 = 2 subnets)</li> <li>3 AZs: Use <code>zone_bits = 2</code> (creates 2^2 = 4 subnets, but we only use 3)</li> </ul> <p>Then split each block per availability zone:</p> <pre><code>web_subnets = {\n  for idx, az in local.azs :\n    az =&gt; {\n      az = az\n      cidr = cidrsubnet(local.vpc_web_subnet_block, local.zone_bits, idx)\n    }\n}\n\nbackend_subnets = {\n  for idx, az in local.azs :\n    az =&gt; {\n      az = az\n      cidr = cidrsubnet(local.vpc_backend_subnet_block, local.zone_bits, idx)\n    }\n}\n\ndatastore_subnets = {\n  for idx, az in local.azs :\n    az =&gt; {\n      az = az\n      cidr = cidrsubnet(local.vpc_datastore_subnet_block, local.zone_bits, idx)\n    }\n}\n</code></pre> <p>Example with 2 AZs (<code>zone_bits = 1</code>): - Web block <code>10.0.0.0/18</code> splits into:   - AZ 1: <code>10.0.0.0/19</code> (idx=0)   - AZ 2: <code>10.0.32.0/19</code> (idx=1) - Backend block <code>10.0.64.0/18</code> splits into:   - AZ 1: <code>10.0.64.0/19</code> (idx=0)   - AZ 2: <code>10.0.96.0/19</code> (idx=1) - Datastore block <code>10.0.128.0/18</code> splits into:   - AZ 1: <code>10.0.128.0/19</code> (idx=0)   - AZ 2: <code>10.0.160.0/19</code> (idx=1)</p> <p>Example with 3 AZs (<code>zone_bits = 2</code>): - Web block <code>10.0.0.0/18</code> splits into:   - AZ 1: <code>10.0.0.0/20</code> (idx=0)   - AZ 2: <code>10.0.16.0/20</code> (idx=1)   - AZ 3: <code>10.0.32.0/20</code> (idx=2) - Backend block <code>10.0.64.0/18</code> splits into:   - AZ 1: <code>10.0.64.0/20</code> (idx=0)   - AZ 2: <code>10.0.80.0/20</code> (idx=1)   - AZ 3: <code>10.0.96.0/20</code> (idx=2) - Datastore block <code>10.0.128.0/18</code> splits into:   - AZ 1: <code>10.0.128.0/20</code> (idx=0)   - AZ 2: <code>10.0.144.0/20</code> (idx=1)   - AZ 3: <code>10.0.160.0/20</code> (idx=2)   - (idx=3 is unused, but that's okay)</p>","tags":["Terraform","cidrsubnet"]},{"location":"blog/2026/01/18/terraform-subnet-splitting/#complete-example","title":"Complete Example","text":"<p>For a VPC with CIDR <code>10.0.0.0/16</code> and 2 availability zones:</p> <pre><code>VPC: 10.0.0.0/16\n\u251c\u2500\u2500 Web: 10.0.0.0/18 (Internet Gateway)\n\u2502   \u251c\u2500\u2500 AZ-1: 10.0.0.0/19\n\u2502   \u2514\u2500\u2500 AZ-2: 10.0.32.0/19\n\u251c\u2500\u2500 Backend: 10.0.64.0/18 (NAT Gateway)\n\u2502   \u251c\u2500\u2500 AZ-1: 10.0.64.0/19\n\u2502   \u2514\u2500\u2500 AZ-2: 10.0.96.0/19\n\u2514\u2500\u2500 Datastore: 10.0.128.0/18 (No NAT Gateway)\n    \u251c\u2500\u2500 AZ-1: 10.0.128.0/19\n    \u2514\u2500\u2500 AZ-2: 10.0.160.0/19\n</code></pre> <p>For 3 availability zones:</p> <pre><code>VPC: 10.0.0.0/16\n\u251c\u2500\u2500 Web: 10.0.0.0/18 (Internet Gateway)\n\u2502   \u251c\u2500\u2500 AZ-1: 10.0.0.0/20\n\u2502   \u251c\u2500\u2500 AZ-2: 10.0.16.0/20\n\u2502   \u2514\u2500\u2500 AZ-3: 10.0.32.0/20\n\u251c\u2500\u2500 Backend: 10.0.64.0/18 (NAT Gateway)\n\u2502   \u251c\u2500\u2500 AZ-1: 10.0.64.0/20\n\u2502   \u251c\u2500\u2500 AZ-2: 10.0.80.0/20\n\u2502   \u2514\u2500\u2500 AZ-3: 10.0.96.0/20\n\u2514\u2500\u2500 Datastore: 10.0.128.0/18 (No NAT Gateway)\n    \u251c\u2500\u2500 AZ-1: 10.0.128.0/20\n    \u251c\u2500\u2500 AZ-2: 10.0.144.0/20\n    \u2514\u2500\u2500 AZ-3: 10.0.160.0/20\n</code></pre>","tags":["Terraform","cidrsubnet"]},{"location":"blog/2026/01/18/terraform-subnet-splitting/#routing-considerations","title":"Routing Considerations","text":"<p>Each subnet type has different routing requirements:</p> <ul> <li>Web subnets: Route table with Internet Gateway for public access</li> <li>Backend subnets: Route table with NAT Gateway for outbound internet access</li> <li>Datastore subnets: Route table with no internet gateway or NAT Gateway (isolated)</li> </ul> <p>This separation ensures that: - Public-facing services are in web subnets with direct internet access - Backend services can reach the internet for updates, API calls, etc., via NAT Gateway - Datastore services remain isolated with no internet access, improving security</p>","tags":["Terraform","cidrsubnet"]},{"location":"blog/2026/01/18/terraform-subnet-splitting/#why-this-approach-works","title":"Why This Approach Works","text":"<ol> <li>Predictable: The hierarchy is clear and easy to understand</li> <li>Scalable: Easy to add more subnet types (e.g., EKS subnets) using the same pattern</li> <li>Balanced: Each subnet type gets equal address space (one-third of the VPC)</li> <li>Flexible: Works for both 2 and 3 AZ scenarios</li> <li> <p>Secure: Clear separation between public, semi-private, and isolated subnets## Additional Considerations</p> </li> <li> <p>When using 3 AZs with <code>zone_bits = 2</code>, you get 4 possible subnets per block but only use 3. The unused subnet (idx=3) is simply not referenced.</p> </li> <li>The first-level split using <code>newbits = 2</code> gives us 4 possible blocks, but we only use 3 (netnum 0, 1, 2). The fourth block (netnum 3) is available for future expansion.</li> <li>This same pattern can be applied to secondary CIDR blocks (like EKS CIDR blocks) using the same logic.</li> <li>The approach ensures that all subnets within a tier (web/backend/datastore) have the same size, which simplifies routing and security group management.</li> </ol>","tags":["Terraform","cidrsubnet"]},{"location":"blog/2026/01/18/terraform-subnet-splitting/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Use <code>cidrsubnet(prefix, 2, 0/1/2)</code> to split a CIDR into three equal blocks (web, backend, datastore)</li> <li>Use <code>zone_bits = 1</code> for 2 AZs, <code>zone_bits = 2</code> for 3 AZs</li> <li>Iterate with <code>for_each</code> or <code>for</code> loops to create subnets per AZ</li> <li>The <code>idx</code> from your loop becomes the <code>netnum</code> parameter</li> <li>Web subnets get Internet Gateway, backend subnets get NAT Gateway, datastore subnets get neither</li> </ul> <p>This approach has served me well for multiple VPC creations, and having it documented here will save me time in the future!</p>","tags":["Terraform","cidrsubnet"]},{"location":"blog/2026/01/27/cross-account-ecr-pull/","title":"Cross Account ECR Image Pull in EKS Cluster","text":"<p>This is for cases when you have one AWS Account (ex: 1234567890) with all ECR images and the workload is running in any AWS accounts like 1234567891, 1234567892, 1234567893, etc.</p> <p>[!CAUTION] This above line is not just one criterion that will help you decide if you want to pull from one account. The decision will also depend on things like: - if the accounts are in same region - if there is NAT Gateway involved in downloading the images - if ECR download is happening using VPC interface Give them a thought before finalising your final workflow. This will save you from unexpected AWS cost suddenly. Having said this, lets move on with rest of the article</p> <p>For each of your accounts (1234567891, 1234567892, 1234567893, etc), add this registry policy in your account with ECR (1234567890):</p> <pre><code>{\n    \"Effect\": \"Allow\",\n    \"Principal\": {\n        \"AWS\": \"arn:aws:iam::1234567891:root\"\n    },\n    \"Action\": [\n        \"ecr:BatchGetImage\",\n        \"ecr:BatchCheckLayerAvailability\",\n        \"ecr:GetDownloadUrlForLayer\",\n        \"ecr:ListImages\"\n    ],\n    \"Resource\": \"arn:aws:ecr:*:1234567890:repository/*\"\n}\n</code></pre> <p>use the policy for other accounts. This will be the policy document that needs to be added:</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Sid\": \"AllowECRAccessTo1234567891\",\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"AWS\": \"arn:aws:iam::1234567891:root\"\n      },\n      \"Action\": [\n        \"ecr:BatchGetImage\",\n        \"ecr:BatchCheckLayerAvailability\",\n        \"ecr:GetDownloadUrlForLayer\",\n        \"ecr:ListImages\"\n      ],\n      \"Resource\": \"arn:aws:ecr:*:1234567890:repository/*\"\n    },\n    {\n      \"Sid\": \"AllowECRAccessTo1234567892\",\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"AWS\": \"arn:aws:iam::1234567892:root\"\n      },\n      \"Action\": [\n        \"ecr:BatchGetImage\",\n        \"ecr:BatchCheckLayerAvailability\",\n        \"ecr:GetDownloadUrlForLayer\",\n        \"ecr:ListImages\"\n      ],\n      \"Resource\": \"arn:aws:ecr:*:1234567890:repository/*\"\n    },\n    {\n      \"Sid\": \"AllowECRAccessTo1234567892\",\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"AWS\": \"arn:aws:iam::1234567892:root\"\n      },\n      \"Action\": [\n        \"ecr:BatchGetImage\",\n        \"ecr:BatchCheckLayerAvailability\",\n        \"ecr:GetDownloadUrlForLayer\",\n        \"ecr:ListImages\"\n      ],\n      \"Resource\": \"arn:aws:ecr:*:1234567890:repository/*\"\n    }\n  ]\n}\n</code></pre> <p>The equivalent AWS cli command to apply this policy will be, where <code>&lt;aws-region-name&gt;</code> is the name of the region where AWS account <code>1234567890</code> exists and <code>&lt;file-name&gt;</code> is the name of the file which was created for this JSON data:</p> <pre><code>aws --region &lt;aws-region-name&gt; ecr put-registry-policy --policy-text file://&lt;file-name&gt;.json\n</code></pre>","tags":["AWS","EKS","Docker"]},{"location":"blog/archive/2026/","title":"2026","text":""},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/category/general/","title":"General","text":""},{"location":"blog/category/terraform/","title":"Terraform","text":""}]}